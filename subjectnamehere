#!/usr/bin/env perl

# Subject Name Here - Randomly generates buzzword-laden pitches for indie games.

use strict;
use warnings;
use v5.16;

# Lingua::EN::Inflect helps us with correctly and consistently placing the
# a/an article in front of nouns.

use Lingua::EN::Inflect qw( A AN );

# List::Util gives us the shuffle() function which we're going to be making
# heavy use of.

use List::Util 'shuffle';

#### Hardcoded Definitions #####
# TODO: Move this off into its own file, preferably in a human-readable format.

my @buzzword_gameplay = (
    'physics', 'time', 'paint', 'gravity', 'colors', 'emotions',
    'zombies' );

my @buzzword_category = (
    'puzzle-platformer', 'rpg', 'top-down shooter',
    'first-person-puzzler', 'art game', 'platformer',
    'immersive sim', 'survival horrror adventure',
    'point-and-click adventure' );

my @buzzword_character = (
   'boy', 'octopus', 'artist', 'film-maker', 'zombie', 'werewolf',
   'mote of dust' );  

my @buzzword_character_adj = qw(
    shy young adventurous colourful funny evil );

my @buzzword_tool = (
    'magical sword', 'laser gun', 'paintbrush', 'biting wit'
);

my @buzzword_macguffin = (@buzzword_tool, (
    'true love', 'a nuclear bomb', 'the secret to eternal life'
));

    
my @buzzword_adj = shuffle( qw(
    roguelike procedural retro social interactive narrative unique
    evocative dynamic story-driven atmospheric old-school hardcore
    casual immersive physics-based skill-adaptive touchscreen-ready
    mind-bending open-ended co-op twitch ) );

# TODO: Actually write this.

sub gen_game_name {
    return "SUBJECT_GAME_HERE";
}

sub gen_character_name {
    return "SUBJECT_CHARACTER_HERE";
}

# Takes a list of items, and returns a reference to an anonymous stateful 
# function that iterates returns those items one at a time in a random order.

sub make_iterator {
    my $i = 0;
    my @buzzwords = shuffle(@_);

    return sub {
        return $buzzwords[$i++];
    };
}

# Same as make_iterator, but returns foo/bar 25% of the time.

sub make_adjectivator {
    # Yeah, yeah, special cases, whatever
    my $i = 0;
    my @buzzwords = @_;

    return sub {
        return $buzzwords[$i++] .
            ((rand > 0.75)?'':('/' . $buzzwords[$i++]));
    };
}

# TODO: This block is awfully repetitious. Figure out a way to do this
# programatically/metaprogramatically, especially because it'll only get
# worse.

my $gen_adjective = make_adjectivator(@buzzword_adj);
my $gen_category = make_iterator(@buzzword_category);
my $gen_gameplay = make_iterator(@buzzword_gameplay);
my $gen_character_adj = make_iterator(@buzzword_character_adj);
my $gen_character_species = make_iterator(@buzzword_character);

#### Composite Generators ####
# Those functions take the primitives we defined before and mash them together
# into sentences and sentence fragments. A common pattern here is to pick random
# functions out of a list of anonymous functions to choose what kind of
# phrase to insert.

sub gen_game_genre {
    return 
        $gen_adjective->() . ' ' .
        $gen_category->();
}

sub gen_with {

    # Variations on a theme.

    my @with_subs = (
        sub {
            return ' with ' . $gen_adjective->() . ' ' . $gen_category->()
                . ' elements.';
        },

        sub {
            return ' that pays homage to classic ' . $gen_adjective->()
                . ' ' . $gen_category->() . ' games.';
        },

        sub {
            return ' based around manipulating ' . $gen_gameplay->() 
                . ' to solve puzzles.';
        },

        sub {
            return ' that is more ' . A($gen_adjective->())
            . ' experiment than a \'game.\'';
        }

    );

    return $with_subs[rand @with_subs]->();
}

sub gen_character {
    return gen_character_name() . ', ' . A($gen_character_adj->() . ' '
        . $gen_character_species->());
}

sub gen_task {
    my @task_subs = (
        sub {
            return ' tasked with defeating ' . gen_character() . '.';
        }
    );

    return $task_subs[rand @task_subs]->();
}

sub gen_protagonist {
    return 'You play as ' . gen_character() . gen_task();
}


sub gen_game_intro {
    return gen_game_name() . ' is ' . A(gen_game_genre() . gen_with());
}

sub print_features {
    # First, we set up a list subroutines that return features.

    my @feature_subs = (
        sub {
            return '- Over ' . int( rand(256) ). ' unique levels!'
        },

        sub {
            return '- Play as ' . A($gen_character_species->()) 
                . ', ' . A($gen_character_species->()) . ' or '
                . A($gen_character_species->())
                . '!';
        },

        sub {
            return '- Free to Play with ' .
                (shuffle ( 
                    'bitcoin-denominated', 'hat-based', 'purely cosmetic' ))[0] .
                ' microtransactions!';
        },

        undef # We use the null value as a delimiter...
    );

    foreach my $sub (shuffle(@feature_subs)) {
        # If we reach the null value, stop iterating.
        # Thus, our list of features has a random number of features.
        last unless $sub;
        print $sub->(), "\n";
    }
}

#### Main ####
# TODO: Command line switches, arguments, etc?

print gen_game_intro, "\n\n";

print gen_protagonist, "\n\n";

print_features();
