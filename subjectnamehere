#!/usr/bin/env perl

# Subject Name Here - Randomly generates buzzword-laden pitches for indie games.

use strict;
use warnings;
use v5.16;

# Lingua::EN::Inflect helps us with correctly and consistently placing the
# a/an article in front of nouns.

use Lingua::EN::Inflect qw( A AN );

# List::Util gives us the shuffle() function which we're going to be making
# heavy use of.

use List::Util 'shuffle';

#### Hardcoded Definitions #####
# TODO: Move this off into its own file, preferably in a human-readable format.

open(BUZZWORDS, '<', 'buzzwords') or die "Can't open buzzword file: $!";

my $current_block_name = 'default';
my @current_block_content;

my %buzzwords;

while (<BUZZWORDS>) {

    chomp;
    s/^\s*(\S*)#.*/$1\n/; # Strip out comments and leading whitespace.
    next if /^$/; # Empty line; do nothing.

    if ( /^\[(.+)\]/ ) { # Start of a new block

        %buzzwords = ( %buzzwords,
            $current_block_name => [ @current_block_content ] );

        $current_block_name = $1;
        @current_block_content = ();
        next
    }

    # If this is neither an empty line nor a block header, assume it's
    # a line containing block content.

    push( @current_block_content, split( qr/\|/, $_ ) );
}

%buzzwords = ( %buzzwords,
    $current_block_name => [ @current_block_content] );

close BUZZWORDS;

# TODO: Actually write this.

sub gen_game_name {
    my @generators = shuffle (

        sub {
            my ($opener) = shuffle(@{$buzzwords{'name:openers'}});
            my ($noun) = shuffle(@{$buzzwords{'name:nouns:plural'}});
            return $opener . ' ' . $noun;
        }
    );

    return $generators[rand @generators]->();

}

# Takes a list of items, and returns a reference to an anonymous stateful 
# function that iterates returns those items one at a time in a random order.

sub make_iterator {
    my $i = 0;
    my @buzzwords = shuffle(@{$_[0]});

    return sub {
        return $buzzwords[$i++];
    };
}

# Same as make_iterator, but returns foo/bar 25% of the time.

sub make_adjectivator {
    # Yeah, yeah, special cases, whatever
    my $i = 0;
    my @buzzwords = @{$_[0]};

    return sub {
        return $buzzwords[$i++] .
            ((rand > 0.75)?'':('/' . $buzzwords[$i++]));
    };
}

# TODO: This block is awfully repetitious. Figure out a way to do this
# programatically/metaprogramatically, especially because it'll only get
# worse.

my $gen_adjective = make_adjectivator($buzzwords{'adj'});
my $gen_category = make_iterator($buzzwords{'category'});
my $gen_gameplay = make_iterator($buzzwords{'gameplay'});
my $gen_character_adj = make_iterator($buzzwords{'character:adj'});
my $gen_character_species = make_iterator($buzzwords{'character'});
my $gen_character_name = make_iterator($buzzwords{'character:names'});

#### Composite Generators ####
# Those functions take the primitives we defined before and mash them together
# into sentences and sentence fragments. A common pattern here is to pick random
# functions out of a list of anonymous functions to choose what kind of
# phrase to insert.

sub gen_game_genre {
    return 
        $gen_adjective->() . ' ' .
        $gen_category->();
}

sub gen_with {

    # Variations on a theme.

    my @with_subs = (
        sub {
            return ' with ' . $gen_adjective->() . ' ' . $gen_category->()
                . ' elements.';
        },

        sub {
            return ' that pays homage to classic ' . $gen_adjective->()
                . ' ' . $gen_category->() . ' games.';
        },

        sub {
            return ' based around manipulating ' . $gen_gameplay->() 
                . ' to solve puzzles.';
        },

        sub {
            return ' that is more ' . A($gen_adjective->())
            . ' experiment than a \'game.\'';
        }

    );

    return $with_subs[rand @with_subs]->();
}

sub gen_character {
    return $gen_character_name->() . ', ' . A($gen_character_adj->() . ' '
        . $gen_character_species->());
}

sub gen_task {
    my @task_subs = (
        sub {
            return ' tasked with defeating ' . gen_character() . '.';
        }
    );

    return $task_subs[rand @task_subs]->();
}

sub gen_protagonist {
    return 'You play as ' . gen_character() . gen_task();
}


sub gen_game_intro {
    return gen_game_name() . ' is ' . A(gen_game_genre() . gen_with());
}

sub print_features {
    # First, we set up a list subroutines that return features.

    my @feature_subs = (
        sub {
            return '- Over ' . int( rand(256) ). ' unique levels!'
        },

        sub {
            return '- Play as ' . A($gen_character_species->()) 
                . ', ' . A($gen_character_species->()) . ' or '
                . A($gen_character_species->())
                . '!';
        },

        sub {
            return '- Free to Play with ' .
                (shuffle ( 
                    'bitcoin-denominated', 'hat-based', 'purely cosmetic' ))[0] .
                ' microtransactions!';
        },

        undef # We use the null value as a delimiter...
    );

    foreach my $sub (shuffle(@feature_subs)) {
        # If we reach the null value, stop iterating.
        # Thus, our list of features has a random number of features.
        last unless $sub;
        print $sub->(), "\n";
    }
}

#### Main ####
# TODO: Command line switches, arguments, etc?

print gen_game_intro, "\n\n";

print gen_protagonist, "\n\n";

print_features();
